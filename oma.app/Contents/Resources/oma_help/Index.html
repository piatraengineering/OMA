<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    
    <meta name="Generator" content="iWeb 2.0.3" />
    <meta name="iWeb-Build" content="local-build-20080211" />
    <meta name="viewport" content="width=720" />
    <title>All Commands</title>
    <link rel="stylesheet" type="text/css" media="screen,print" href="Index_files/Index.css" />
    <!--[if IE]><link rel='stylesheet' type='text/css' media='screen,print' href='Index_files/IndexIE.css'/><![endif]-->
    <script type="text/javascript" src="Scripts/iWebSite.js"></script>
    <script type="text/javascript" src="Scripts/Widgets/SharedResources/WidgetCommon.js"></script>
    <script type="text/javascript" src="Scripts/Widgets/Navbar/navbar.js"></script>
    <script type="text/javascript" src="Index_files/Index.js"></script>
  </head>
  <body style="background: #ffffff; margin: 0pt; " onload="onPageLoad();" onunload="onPageUnload();">
    <div style="text-align: center; ">
      <div style="margin-bottom: 0px; margin-left: auto; margin-right: auto; margin-top: 0px; overflow: hidden; position: relative; word-wrap: break-word;  background: #ffffff; text-align: left; width: 720px; " id="body_content">
        <div style="float: left; height: 0px; line-height: 0px; margin-left: 0px; position: relative; width: 720px; z-index: 10; " id="header_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
        </div>
        <div style="margin-left: 0px; position: relative; width: 720px; z-index: 0; " id="nav_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
          <div class="com-apple-iweb-widget-navbar flowDefining" id="widget0" style="margin-left: 35px; margin-top: 0px; position: relative; width: 630px; z-index: 1; ">
    
            <div id="widget0-navbar" class="navbar">

      
              <div id="widget0-bg" class="navbar-bg">

        
                <ul id="widget0-navbar-list" class="navbar-list">
 <li></li> 
</ul>
                
      
</div>
              
    
</div>
          </div>
          <script type="text/javascript"><!--//--><![CDATA[//><!--
new NavBar('widget0', 'Scripts/Widgets/Navbar', 'Scripts/Widgets/SharedResources', '.', {"current-page-GUID": "A91805B9-A1AC-4E06-866B-CB13A0EC6F00", "path-to-root": "", "isCollectionPage": "NO", "navbar-css": ".navbar {\n\tfont-family: Arial, sans-serif;\n\tfont-size: 1em;\n\tcolor: #666;\n\tmargin: 9px 0px 6px 0px;\n\tline-height: 30px;\n}\n\n.navbar-bg {\n\ttext-align: center;\n}\n\n.navbar-bg ul {\n\tlist-style: none;\n\tmargin: 0px;\n\tpadding: 0px;\n}\n\n\nli {\n\tlist-style-type: none;\n\tdisplay: inline;\n\tpadding: 0px 10px 0px 10px;\n}\n\n\nli a {\n\ttext-decoration: none;\n\tcolor: #666;\n}\n\nli a:visited {\n\ttext-decoration: none;\n\tcolor: #666;\n}\n\nli a:hover\r{\r\n \tcolor: #463C3C;\n\ttext-decoration: none;\r}\n\n\nli.current-page a\r{\r\t color: #463C3C;\n\ttext-decoration: none;\n\tfont-weight: bold;\r\r}"});
//--><!]]></script>
          <div style="clear: both; height: 0px; line-height: 0px; " class="spacer"> </div>
        </div>
        <div style="margin-left: 0px; position: relative; width: 720px; z-index: 5; " id="body_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
          <div style="height: 1px; line-height: 1px; " class="tinyText"> </div>
          <div style="margin-left: 35px; margin-top: 76px; position: relative; width: 630px; z-index: 1; " class="style_SkipStroke flowDefining">
            <div class="text-content style_External_630_27152" style="padding: 0px; ">
              <div class="style">
                <p style="padding-top: 0pt; " class="paragraph_style">- x<br /></p>
                <p class="paragraph_style">    Subtracts x from the data in the current image data buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">* x<br /></p>
                <p class="paragraph_style">    Multiplies the data in the current image data buffer by x.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">*RGB x y z<br /></p>
                <p class="paragraph_style">    For the current (assumed RGB) image in the buffer, multiply the red part by x, the green part by y, and the blue part by z.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">/ x<br /></p>
                <p class="paragraph_style">    Divides the data in the current image data buffer by x.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">/RGB x y z<br /></p>
                <p class="paragraph_style">    For the current (assumed RGB) image in the buffer, divide the red part by x, the green part by y, and the blue part by z.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">+ x<br /></p>
                <p class="paragraph_style">    Adds x to the data in the current image data buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">+RGB x y z<br /></p>
                <p class="paragraph_style">    Add x to the red, y to the green, and z to the blue part of the current (assumed RGB) image in the buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">3DDELETE<br /></p>
                <p class="paragraph_style">    Delete the 3D data array built up with 3DSTORE commands.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">3DSAVE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Save the 3D data array to a file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">3DSTORE<br /></p>
                <p class="paragraph_style">    Store the current image as the next slice of a 3D array.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">3DXZ n<br /></p>
                <p class="paragraph_style">    Get the nth x-z slice of the 3D data array.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">3DYZ n<br /></p>
                <p class="paragraph_style">    Get the nth y-z slice of the 3D data array.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ABELCLEAN X<br /></p>
                <p class="paragraph_style">    Try to clean up Abel inverted images. Calculate average horizontal gradient magnitude. If the average horizontal gradient in a single line is more than X times greater than the average, replace the line with the average of the lines above and below.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ABSOLUTE<br /></p>
                <p class="paragraph_style">    Take the absolute value of the data in the current image data buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ACADD<br /></p>
                <p class="paragraph_style">    Adds the current image data buffer to the accumulator buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ACCUMULATE<br /></p>
                <p class="paragraph_style">    Allocates and clears memory for an image accumulator buffer that can be used to sum individual images. The size of the accumulator is determined by the image size parameters when the accumulate command is first given.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ACDELETE<br /></p>
                <p class="paragraph_style">    Frees the memory associated with the accumulator. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ACGET<br /></p>
                <p class="paragraph_style">    Moves the data from the accumulator buffer into the current image data area. The previous contents of the image data buffer are destroyed.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ACPDF n<br /></p>
                <p class="paragraph_style">    Accumulate a pdf of 2 variables. The binning parameters are selected with the ACSPDF command. n is the single channel of the data to be used in accumulating the pdf. (Yale Command.)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ACSPDF start_val bin_width<br /></p>
                <p class="paragraph_style">    Setup for the ACPDF command. Must specify: <br /></p>
                <p class="paragraph_style">    Starting Value <br /></p>
                <p class="paragraph_style">    Bin Width<br /></p>
                <p class="paragraph_style">    Note that the number of bins is specified by the size of the 2D array defined when the accumulator is defined with the ACCGET command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ADDFILE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Adds the contents of an OMA file of a given name to the data in the current image data buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ADDTMP n<br /></p>
                <p class="paragraph_style">    Adds the contents of temporary image n to the data in the current image data buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">AINPUT [channel]<br /></p>
                <p class="paragraph_style">    Reads the analog input from the specified channel (default is 0) of a Labjack U12 USB analog/digital  I/O device. The value (in volts) is returned in command_return_1.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">AMASK value<br /></p>
                <p class="paragraph_style">    Make a “mask” corresponding to air in Rayleigh flame images. Set new image value to 1 under the following conditions: <br /></p>
                <p class="paragraph_style">    image value &gt; value<br /></p>
                <p class="paragraph_style">    All image values along the current row have satisfied the above condition as well. <br /></p>
                <p class="paragraph_style">    Otherwise, set the image value to 0. This assumes the cold air part of the image is on the left hand side.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ANGRAD<br /></p>
                <p class="paragraph_style">    Replace the image with and image that represents the angle of the gradient at each point.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">AOUTPUT v1 v2 [v3 v4]<br /></p>
                <p class="paragraph_style">    Sends voltages to D/A converters 0 and 1 on a Labjack USB analog/digital I/O device.<br /></p>
                <p class="paragraph_style">    If a Labjack U3 is present, v1 and v2 are sent to it.<br /></p>
                <p class="paragraph_style">    If there is no U3 but there is a Labjack U12, v1 and v2 are sent to the U12.<br /></p>
                <p class="paragraph_style">    If both U3 and U12 Labjacks are present and all 4 voltages are given, v1 and v2 are sent to the U3 and v3 and v4 are sent to the U12.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ASPECTRATIO [aspect_ratio]<br /></p>
                <p class="paragraph_style">    If aspect_ratio is 0 (or the argument is omitted), the aspect ratio of the tool rectangle is as drawn with the cursor. If aspect_ratio is set to a nonzero value with the ASPECTRATIO command, rectangles drawn with the cursor will be constrained to the specified aspect ratio. The aspect ratio is width/height.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTDIAMETER &lt;microns&gt;<br /></p>
                <p class="paragraph_style">    If &lt;microns&gt; is specified on the command line then the Attenuation parameter for Mean Particle Diameter is set to that value. If this command is called without arguments then the Attenuation dialog box is opened.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTENUATION<br /></p>
                <p class="paragraph_style">    Runs the Attenuation algorithm in OMA on the image in the buffer. Attenuation parameters are specified using ATTVALUES. The OMA buffer contains the corrected intensity image. Other intermediate images are in the temporary buffers:<br /></p>
                <p class="paragraph_style">    Temp[0]: The original image<br /></p>
                <p class="paragraph_style">    Temp[1]: The K_div image (laser fluence correction for divergence)<br /></p>
                <p class="paragraph_style">    Temp[2]: The local transmission fraction in a pixel due to extinction by particles, K_trans<br /></p>
                <p class="paragraph_style">    Temp[3]: The Ck image<br /></p>
                <p class="paragraph_style">    Temp[4]: The mean Particle cross-section distribution<br /></p>
                <p class="paragraph_style">    Temp[5]: The number of standard particles in each pixel (N_p)<br /></p>
                <p class="paragraph_style">    Temp[6]: The extinction history at each point.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTIPRESOLUTION &lt;microns&gt;<br /></p>
                <p class="paragraph_style">    If &lt;microns&gt; is specified on the command line then the Attenuation parameter for In-Plane (CCD) Resolution is set to that value. If this command is called without arguments then the Attenuation dialog box is opened. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTLSTHICKNESS &lt;microns&gt;<br /></p>
                <p class="paragraph_style">    If &lt;microns&gt; is specified on the command line then the Attenuation parameter for Laser Sheet Thickness is set to that value. If this command is called without arguments then the Attenuation dialog box is opened.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTPRINT<br /></p>
                <p class="paragraph_style">    Prints the Attenuation parameters to the OMA Command Window. Attenuation parameters are set with ATTVALUES.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTSCALE &lt;arg1&gt;<br /></p>
                <p class="paragraph_style">    If &lt;arg1&gt; is specified on the command line then the Attenuation parameter for Ck scaling parameter is set to that value. If this command is called without arguments then the Attenuation dialog box is opened.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ATTVALUES &lt;xloc&gt; &lt;yloc&gt;<br /></p>
                <p class="paragraph_style">    Called with two arguments, this command sets the location of the  Virtual Origin for the Attenuation algorithm. The V.O must be off the  LHS of the image. If this is not the case, use FLIPH or ROTATE to make it so. The location of the V.O. is with respect the OMA origin, which is top-left corner of the image. If this command is called without arguments then the Attenuation dialog box is opened. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">AVERAGE<br /></p>
                <p class="paragraph_style">    This command calculates the average of the NON-ZERO pixels in the image and then writes this value into every pixel in the image. This allows the AVERAGE value to be easily passed into OMA Macros by using %b. We will let this still wreck the buffer for compatibility, but we will be more clever about passing results out in the command_return_N variables.<br /></p>
                <p class="paragraph_style">    command_return_1  Average of non-zero pixels<br /></p>
                <p class="paragraph_style">    command_return_2  Average of ALL pixels<br /></p>
                <p class="paragraph_style">    command_return_3  rms of non-zero pixels<br /></p>
                <p class="paragraph_style">    command_return_4  rms of all pixels<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">BINBYTE byte_num<br /></p>
                <p class="paragraph_style">    Specify the number of bytes per dataword for files to be read with GETBINARY. If byte_num is -sizeof(float), the binary data are treated as float (i.e., byte_num = -4). Other reasonable values would be 1, 2, or 4.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">BINSIZE #columns #rows #header_bytes swap_bytes_flag<br /></p>
                <p class="paragraph_style">    Specify parameters for files to be read with GETBINARY.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">BIT8 [min] [max]<br /></p>
                <p class="paragraph_style">    Converts the file in the OMA image buffer to have a dynamic range of 0 to 255. That is, 8 unsigned bits per pixel. This conversion is automatically done before saving the image buffer as a TIFF image. If the optional min and max are specified, they are used for the scaling rather than the min and max of the current image buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">BLKAVE n<br /></p>
                <p class="paragraph_style">    Set a flag that determines whether or not the BLOCK command sums or averages the values within the specified block. If n = 0, sum values. Otherwise, average. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">BLOCK n [m]<br /></p>
                <p class="paragraph_style">    Group the image data into n x m blocks. This command reduces the size of the data buffer. The values are averaged or summed, depending on the flag specified with the BLKAVE command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">BLOCKRGB n [m]<br /></p>
                <p class="paragraph_style">    Group the RGB image data into n x m blocks. This command reduces the size of the data buffer. The values are averaged or summed, depending on the flag specified with the BLKAVE command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CALCALL<br /></p>
                <p class="paragraph_style">    Print calculations on the entire image. The average, rms, # of points, and the x and y “center of mass” are printed. The mean, rms, centroid_X and centroid_Y are passed to the command_return_variables.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CALCULATE<br /></p>
                <p class="paragraph_style">    Print calculations on the rectangle specified with the RECTANGLE command or with the rectangle tools. The average, rms, # of points, and the x and y “center of mass” are printed. The mean, rms, centroid_X and centroid_Y are passed to the command_return_variables.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CCD x y<br /></p>
                <p class="paragraph_style">    Specifies that the detector is a CCD and therefore has an additional 80 word header preceding the data. The maximum width is x and maximum height is y.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CHANEL n <br /></p>
                <p class="paragraph_style">    Specifies that n channels (or columns) are to be scanned.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CLIP n<br /></p>
                <p class="paragraph_style">    Sets all data values in the current image buffer that are &gt; n to n. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CLIPFRACT fraction<br /></p>
                <p class="paragraph_style">    Clip data at a fraction of the maximum value. Fraction is a real argument. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CLOSE  <br /></p>
                <p class="paragraph_style">    Closes the file opened with the CREATE command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CMINMX n m <br /></p>
                <p class="paragraph_style">    Specifies the minimum (n) and maximum (m) values in the data that correspond to the minimum and maximum color or gray scale values. Specifying the values causes the “Auto Scale” feature to be disabled. If the arguments are not given, the “Auto Scale” feature is enabled.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">COLUMN n <br /></p>
                <p class="paragraph_style">    Specifies that n channels (or columns) are to be scanned.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">COMPOSITE &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Create a composite image by appending the data in the specified file to that which exists in the current image buffer. The width of the specified file must be the same as that of the current image. The OPENFLAG command works in conjunction with the COMPOSITE command in the same way that it does with the GET command. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">COMTMP n <br /></p>
                <p class="paragraph_style">    Create a composite image by appending the data in the temporary image to that which exists in the current image buffer. The width of the specified file must be the same as that of the current image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CONCATENATE  <br /></p>
                <p class="paragraph_style">    Saves the current data buffer to the file opened with the CREATE command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CORECT n<br /></p>
                <p class="paragraph_style">    Performs corrections on the data in the current image buffer by subtracting the background saved with the SBACK command, multiplying that result by n, and then dividing by the response saved with the SRESPONSE command. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">COSMOOTH dx dy cnt name<br /></p>
                <p class="paragraph_style">    Contour-smoothing: where cnt is the nominal 1/2 width of contour interval (in counts) and name is the name of file to be smoothed. Read in Rayleigh file into buffer first.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">COUNT <br /></p>
                <p class="paragraph_style">    Count the number of distinct objects above a zero background. The original image is replaced. The maximum value is the number of objects. Try this:<br /></p>
                <p class="paragraph_style">    SIN 50 50  ; create an image<br /></p>
                <p class="paragraph_style">    DISP<br /></p>
                <p class="paragraph_style">    COUNT   ; count the peaks<br /></p>
                <p class="paragraph_style">    DISP<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CREATE &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Opens a file with the specified name, saves the current data and format information, and leaves the file open. Subsequently, the CONCATINATE command can be used to add more data to the open file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CROP<br /></p>
                <p class="paragraph_style">    Use the current rectangle to crop the image in the buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CROPRGB<br /></p>
                <p class="paragraph_style">    Use the current rectangle to crop the (assumed RGB) image in the buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CTRLST [num_pts]<br /></p>
                <p class="paragraph_style">    Treat the current image as a set of connected contours. Make lists of the x-y pixels that define the contour, goes clockwise, nonzero values are on the contour. After the routine is done, the original image should all be zeros. Number of closed contours varies depending on the image. num_pts is the number of points on either side.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">CYLIMAGE [COPX COPY COPZ]<br /></p>
                <p class="paragraph_style">    Treat the data in the current image as a half cross section of a cylindrically symmetric intensity distribution. The centerline is assumed to be along the LHS of the image. An integrated image is calculated by rotating the image  about the centerline. A pinhole camera imaging configuration is assumed, with the center of projection specified by the COPX COPY and COPZ coordinates. Default values are COPX = 0, COPY = imageheight/2, and COPZ = 1.0E10.  (COPX = 0 means camera is centered, COPZ is the distance to the camera. Units for COPX, COPY, and COPZ are in pixels)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DAUTOCORR npix<br /></p>
                <p class="paragraph_style">    Displays autocorrelation of the data in the image buffer. The size of the autocorrelation region is specified by the PIVSIZE command. Drag the curser over the data image to choose the center of the autocorrelation region. “npix” specifies the magnification of autocorrelation window.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DELAY nticks<br /></p>
                <p class="paragraph_style">    Waits nticks/60 seconds before continuing on to the next command. Use this for rough timing operations.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DFFT npix<br /></p>
                <p class="paragraph_style">    Using the size specified by the PIVSIZE command, zoom in on the Fourier Transform of the area of the image centered on the cursor. “npix”  specifies the magnification of the FFT window.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DFILTER dt tmax<br /></p>
                <p class="paragraph_style">    Nonlinear diffusion filter -- supposed to smooth with out messing up gradients. See paper by Kaminski.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DIFFX<br /></p>
                <p class="paragraph_style">    Differentiate the data in the current image data buffer in the x direction. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DIFFY<br /></p>
                <p class="paragraph_style">    Differentiate the data in the current image data buffer in the y direction. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DISOFF flag<br /></p>
                <p class="paragraph_style">    If flag = 1, DISPLA Y commands will be ignored. This can be used to speed large batch processing macros. flag = 0 resumes normal DISPLA Y operation.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DISPLAY [string] <br /></p>
                <p class="paragraph_style">    Opens a window on the Macintosh screen and displays the contents of the current data buffer. The color palette used can be determined by the PALETTE command. The color minimum and maximum are specified by the CMINMX command. There can be up to 9 image windows open at one time. Windows can be resized, moved around the screen, and closed as in other Macintosh applications. If the optional string is specified, the window will be named according to the string.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DIST2N value<br /></p>
                <p class="paragraph_style">    Swap every pixel with distance to nearest neighbor with value &lt;value&gt;<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DIVFILE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Divides the data in the current buffer by the contents of the specified file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DIVTMP n<br /></p>
                <p class="paragraph_style">    Divides the data in the current buffer by the contents of temporary image n.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DMACRO [n] [command]<br /></p>
                <p class="paragraph_style">    Prompts the user for lines of a command macro to be executed using the RMACRO command. If the argument n is omitted, definition starts with line one. If n is specified, definition begins with the nth line of the macro. To include numerical arguments that change each time the macro is executed, %d can be inserted in the macro command at the location where the number will be placed upon execution of the macro. If “command” is not present, the program prompts for additional command lines until a null command is entered (i.e. &lt;CR&gt; only). If the optional “command” is included on the same line, the text of “command” replaces any command already existing at line n and no further command lines are solicited. Dummy arguments in Macros or Execute files include the following:<br /></p>
                <p class="paragraph_style">    %c  the number of seconds since OMA was started (float)<br /></p>
                <p class="paragraph_style">    %d  a decimal digit<br /></p>
                <p class="paragraph_style">    %s  the string specified by the STRMAC command<br /></p>
                <p class="paragraph_style">    %f  last file name<br /></p>
                <p class="paragraph_style">    %b  maximum value (big)<br /></p>
                <p class="paragraph_style">    %l  minimum value (little)<br /></p>
                <p class="paragraph_style">    %m  multiplier (the current scale factor)<br /></p>
                <p class="paragraph_style">    %t  current date and time<br /></p>
                <p class="paragraph_style">    %v  an integer value that increments by a specified amount every time it is used<br /></p>
                <p class="paragraph_style">    Use the VALMAC command to specify the starting value and increment.<br /></p>
                <p class="paragraph_style">    %e  the result of the last error code (0 means no error)<br /></p>
                <p class="paragraph_style">    %a  the average within the currently defined rectangle<br /></p>
                <p class="paragraph_style">    %r  the rms within the currently defined rectangle<br /></p>
                <p class="paragraph_style">    %h  the height of the current image<br /></p>
                <p class="paragraph_style">    %w  the width of the current image<br /></p>
                <p class="paragraph_style">    %x  the x pixel coordinate of the last mouse click<br /></p>
                <p class="paragraph_style">    %y  the y pixel coordinate of the last mouse click<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DMNMX<br /></p>
                <p class="paragraph_style">    Displays the color min and max in the window.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DOUT state<br /></p>
                <p class="paragraph_style">    Sets digital I/O bit 2 to low (state = 0) or high (state = 1) on a LabJack U12<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DRGB [string] <br /></p>
                <p class="paragraph_style">    Opens a window and displays the contents of the current image buffer as an RGB image -- the first third of the image is taken as values for the red bit plane, the second third of the image represents the green bit plane, followed by the blue. This is the ordering of data read in from RAW or JPG images. The CMINMX command and “+” and “-” buttons in the status window work as for single-bit-plane images. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DX n<br /></p>
                <p class="paragraph_style">    Specifies the number of detector pixels (not display screen pixels) to be grouped (or binned) in the X direction.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DY n<br /></p>
                <p class="paragraph_style">    Specifies the number of detector pixels (not display screen pixels) to be grouped in the Y direction.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">DZOOM npix<br /></p>
                <p class="paragraph_style">    Using the size specified by the current rectangle, zoom in on an area of the image centered on the cursor. Zoom factor is npix (integer). This is good for getting a close-up of a sub-region of an image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ECHO string<br /></p>
                <p class="paragraph_style">    Prints “string” during macro execution. “string” can be replaced with any of the macro dummy arguments (e.g., ECHO %b).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ENDIF<br /></p>
                <p class="paragraph_style">    Terminates an IF command. This is applicable within Macros only.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ERASE [n] <br /></p>
                <p class="paragraph_style">    If no argument is given, all image windows currently on the screen are closed. If a value n is specified, only window n is erased.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">EXECUTE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Reads OMA commands stored in the specified file into a special execute buffer and then performs those commands. Unlike macros, these should not contain dummy numerical arguments (%d).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">EXIT <br /></p>
                <p class="paragraph_style">    Terminates execution of a program.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">EXP scale_factor denom<br /></p>
                <p class="paragraph_style">    Result is scale_factor*exp(data/denom)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FCALC<br /></p>
                <p class="paragraph_style">    Using the data in the current buffer as rayleigh input and the specified file as the fluorescence input, create the conserved scalar image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FCCASE<br /></p>
                <p class="paragraph_style">    Set the information that the fcalc command returns.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FCLOSE<br /></p>
                <p class="paragraph_style">    Closes the currently open text file (there can be only one). The use of FOPEN, FCLOSE, and FECHO allows derived values to be written to a file from within a macro.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FCONST<br /></p>
                <p class="paragraph_style">    Read in constants to be used for FCALC.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FECHO %s<br /></p>
                <p class="paragraph_style">    Exactly as echo but instead of printing to the command window, it writes to the file opened with FOPEN. The use of FOPEN, FCLOSE, and FECHO allows derived values to be written to a file from within a macro.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FFT mode scale_factor<br /></p>
                <p class="paragraph_style">    mode = 0  return the magnitude scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 1   return the real part scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 2   return the imaginary part scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 3   return inverse - input is real part scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 4   return inverse - input is imaginary part scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 5  return the log of the magnitude squared scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 6  return the magnitude squared scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 7  return the autocorrelation scaled by scale_factor<br /></p>
                <p class="paragraph_style">    mode = 8  return inverse - input is a filter scaled by n<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FILBOX<br /></p>
                <p class="paragraph_style">    Replace the data within the rectangle by interpolating between values on left and right of rectangle.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FILMSK &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Use the specified file as a mask to define regions of the image where data should be interpolated between values on the left and right. An example of the use for this command would be to remove particles from a Rayleigh image. The mask could be formed by finding portions of the image with large gradient, smoothing, and clipping.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FINDPEAK center start end<br /></p>
                <p class="paragraph_style">    Locates peak within window designated (Center, +, -).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FLIPHORIZ<br /></p>
                <p class="paragraph_style">    Flips the image in the OMA buffer horizontally<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FLIPVERT<br /></p>
                <p class="paragraph_style">    Flips the image in the OMA buffer vertically<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FLOAT variable_name<br /></p>
                <p class="paragraph_style">    Specifies that variable_name is to be used as a floating point variable.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FLUCTUATION n<br /></p>
                <p class="paragraph_style">    Calculates a fluctuation by subtracting the mean saved with the SMEAN command. If n=0, the fluctuation is calculated. If n is not 0, the fluctuation^2/n is returned. No check is made for overflow. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FMAXHORIZ<br /></p>
                <p class="paragraph_style">    Scans an image horizontally. For each row, the pixel(s) holding the maximum value in that row are left alone. All other pixels are set to zero.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FMAXVERT<br /></p>
                <p class="paragraph_style">    Scans an image vertically. For each column, the pixel(s) holding the maximum value in that column are left alone. All other pixels are set to zero.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FOPEN &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Open a text file with the name &lt;filename&gt; for I/O. The use of FOPEN, FCLOSE, and FECHO allows derived values to be written to a file from within a macro.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FRAME NewWidth NewHeight [Value] [X0] [Y0]<br /></p>
                <p class="paragraph_style">    Put a “frame” around the current image -- making it a new size.<br /></p>
                <p class="paragraph_style">    Default Value is 0.<br /></p>
                <p class="paragraph_style">    Default of X0 and Y0 center the old image in the frame.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FRAME2 NewWidth NewHeight [Value] [X0] [Y0] <br /></p>
                <p class="paragraph_style">    Put a “frame” around the current image. Same idea as the FRAME command but more robust and more consistent in the definition of X0 and Y0. X0 and Y0 are the coordinates of the start of the new image in the current image's coordinate system. X0 and Y0 can be positive (will crop out some of the current image) or negative (The new image will have a border with the pixels containing the Value specified). If X0 or Y0 are not integers, the routine will interpolate pixel values. Default Value is 0. Default of X0 and Y0 center the old image in the frame.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FRDATA &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Read formatted data (in the format written with FWDATA).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FRDATMAT &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Reads the data in a delimited text file. Use this to import 2D arrays from Excel or Matlab (for example). Can also read files written with the FWDATM command. Format is a matrix of values as follows: <br /></p>
                <p class="paragraph_style">    first row of data values <br /></p>
                <p class="paragraph_style">    second row of data values <br /></p>
                <p class="paragraph_style">    . <br /></p>
                <p class="paragraph_style">    . <br /></p>
                <p class="paragraph_style">    .<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FREEMEMORY<br /></p>
                <p class="paragraph_style">    Free the memory from the background, mean, and response.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FTEMP n<br /></p>
                <p class="paragraph_style">    Free memory associated with temporary image n.<br /></p>
                <p class="paragraph_style">    n must be in the range 0-9.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FUEL ctr1 ctr2 name<br /></p>
                <p class="paragraph_style">    Fuel: command is “fuel ctr1 ctr2 name”, where ctr1 is the fuel contour at which the Rayleigh image will be cut to form a new fuel image. ctr 2 is a different contour value to determine the scaling and offset for this shot. name is the name of the Raman image. Read the Rayleigh image file into buffer first.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FWDATA &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Writes the data in the current buffer as a tab-delimited text file. Format is as follows: <br /></p>
                <p class="paragraph_style">    image_width image_height <br /></p>
                <p class="paragraph_style">    1 first data value <br /></p>
                <p class="paragraph_style">    2 second data value <br /></p>
                <p class="paragraph_style">    . <br /></p>
                <p class="paragraph_style">    . <br /></p>
                <p class="paragraph_style">    .<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">FWDATMAT &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Writes the data in the current buffer as a tab-delimited text file. Format is a matrix of integer values as follows: <br /></p>
                <p class="paragraph_style">    first row of data values <br /></p>
                <p class="paragraph_style">    second row of data values <br /></p>
                <p class="paragraph_style">    . <br /></p>
                <p class="paragraph_style">    . <br /></p>
                <p class="paragraph_style">    .<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GET &lt;filename&gt;  <br /></p>
                <p class="paragraph_style">    Loads the data from the specified file into the current image data buffer. The “Get Data Files” prefix and suffix are used.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETANGLE <br /></p>
                <p class="paragraph_style">    Calculate the angle that the current image needs to be rotated to align the x center of mass with the y axis. The region inside the current rectangle is considered. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETBINARY &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Read in a binary file. Use BINSIZE to specify the format of the binary file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETBKG<br /></p>
                <p class="paragraph_style">    Writes to each pixel in the image a value that is the calculated average of all non-zero pixels in the original image, PLUS 3 times the rms. The original image is destroyed. This command is useful for stripping the background values from noisy CCD's by passing this 'background' value to variables within a macro. See also AVERAGE. We will let this still wreck the buffer for compatibility, but we will be more clever about passing results out in the command_return_N variables.<br /></p>
                <p class="paragraph_style">    command_return_1  Average of non-zero pixels<br /></p>
                <p class="paragraph_style">    command_return_2  Average of ALL pixels<br /></p>
                <p class="paragraph_style">    command_return_3  rms of non-zero pixels<br /></p>
                <p class="paragraph_style">    command_return_4  rms of all pixels<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETBLUE &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Open the blue part of a digital camera RAW image specified by the filename. The extension should be given in the filename (it does not use the suffix). This uses Dave Coffin's very slick dcraw.c code. This command can also open the blue plane of “.jpg” files.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETFIT &lt;filename&gt;  <br /></p>
                <p class="paragraph_style">    Loads an image file in FITS format into the current image data buffer. Assumes the extension is .fts (ignores the suffix in get file prefs)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETFUNCT n &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Read in a tabulated function to be used with the LOOKUP command. This is also used in the C function tabfun(fn_number, x_val). Filename is file containing y=f(x) data pairs, preceded by number of table entries.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETGRN &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Open the green part of a digital camera RAW image specified by the filename. The extension should be given in the filename (it does not use the suffix). This uses Dave Coffin's very slick dcraw.c code. This command can also open the green plane of “.jpg” files.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETMATCH parameterfile<br /></p>
                <p class="paragraph_style">    Load the file matching parameters contained in the text file “parameterfile”. The format of the file is as follows:<br /></p>
                <p class="paragraph_style">    x1_ref y1_ref x1_i1 y1_i1 x1_i2 y1_i2<br /></p>
                <p class="paragraph_style">    x2_ref y2_ref x2_i1 y2_i1 x2_i2 y2_i2<br /></p>
                <p class="paragraph_style">    image1_width image1_height<br /></p>
                <p class="paragraph_style">    image2_width image2_height<br /></p>
                <p class="paragraph_style">    Note that there is no prefix added to the file name.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETPIC &lt;filename&gt;  <br /></p>
                <p class="paragraph_style">    Opens an image file in PICT format. It is not automatically moved to the image buffer. Use GWINDO if you want this. NOT IMPLEMENTED IN VERSIONS BEYOND 2.0.6 <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETRED &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Open the red part of a digital camera RAW image specified by the filename. The extension should be given in the filename (it does not use the suffix). This uses Dave Coffin's very slick dcraw.c code. This command can also open the red plane of “.jpg” files.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETRGB &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Open a digital camera RAW image specified by the filename. The extension should be given in the filename (it does not use the suffix). The red, green, and blue images are staked one on top of the other in a single image. This uses Dave Coffin's very slick dcraw.c code. This command can also open “.jpg” files.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GETSETTINGS [filename]<br /></p>
                <p class="paragraph_style">    Gets settings from the specified file (uses the appropriate prefix and suffix specified in the preferences). If no filename is given, OMA Settings from within the oma application are loaded. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GMACRO &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Loads the contents of the specified file into the current macro buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GNOISE mean rms [seed]<br /></p>
                <p class="paragraph_style">    Gaussian deviate generator using built-in random-number Generator followed by Box-Muller transform<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GRAD2<br /></p>
                <p class="paragraph_style">    Find the magnitude of the gradient of the data in the current image buffer. Use the current pixel and the one next to it for gradient.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GRADIENT<br /></p>
                <p class="paragraph_style">    Find the magnitude of the gradient of the data in the current image buffer. Use 2 pixels on either side of current pixel for gradient.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GRADPK n<br /></p>
                <p class="paragraph_style">    Determine gradient magnitude from 4 points at a distance n from center pixel.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GSMOO2 dx [dy]<br /></p>
                <p class="paragraph_style">    Gaussian Smoothing of the Data. dx and dy are the smoothing size parameters. If dy is omitted, it is taken as dx. dx and dy must be odd. sigma_x = (dx-1)/6.0<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GSMOOTH dx [dy]<br /></p>
                <p class="paragraph_style">    Gaussian Smoothing of the Data. dx and dy are the smoothing size parameters. If dy is omitted, it is taken as dx. dx and dy must be odd. sigma_x = (dx-1)/3.5<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GTEMP n<br /></p>
                <p class="paragraph_style">    Get temporary image n that has been previously saved using STEMP n.<br /></p>
                <p class="paragraph_style">    n must be in the range 0-9.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GTIFF &lt;filename&gt; [n] <br /></p>
                <p class="paragraph_style">    Loads the file specified in 'filename' into the OMA image buffer. Three-plane, 8-bit per pixel images can be loaded (use DRGB for color display). Files up to 1-bit grey scale can be read. The optional argument [n] (default=0) specifies the page number (IFD) of the image to be read from TIFF files that have more than one image within a file. The first IFD is number 0.<br /></p>
                <p class="paragraph_style">    The number of samples per pixel is returned as variable command_return_1.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">GWINDO <br /></p>
                <p class="paragraph_style">    Moves the contents of the current display window into the image data buffer. This can be used to get an OMA data representation of images available as a Macintosh graphics window. The resulting values will be in the range 1-251.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">HELP [command name or fragment]<br /></p>
                <p class="paragraph_style">    If a command name is given, a brief explanation of the command is printed in the command window. If only part of the command is given, a description of all commands that match the command fragment is printed. All help information is from the file “OMA HELP.” If no argument is given, all command names are printed with no explanation.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IF condition<br /></p>
                <p class="paragraph_style">    If condition evaluates to a non-zero value, the commands following the IF are executed. However, if the condition is zero, the commands between IF and ENDIF are not executed. The condition can be any arithmetic statement and can include logical operators &lt; (less than), &gt; (greater than), others to come....<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IFDEFINED variable_name<br /></p>
                <p class="paragraph_style">    If the specified variable_name is defined, the condition is satisfied, and the macro commands following the IFDEF command will be executed.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IFEXST &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    If the specified filename exists, the condition is satisfied, and the macro commands following the IFEXST command will be executed. <br /></p>
                <p class="paragraph_style">    Note: the SAVE prefix and suffix are applied to the filename before the test is done.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IFNDEFINED variable_name<br /></p>
                <p class="paragraph_style">    If the specified variable_name is not defined, the condition is satisfied, and the macro commands following the IFNDEF command will be executed.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IFNEXS &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    If the specified filename does not exist, the condition is satisfied, and the macro commands following the IFNEXS command will be executed. <br /></p>
                <p class="paragraph_style">    Note: the SAVE prefix and suffix are applied to the filename before the test is done.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IMACRO n<br /></p>
                <p class="paragraph_style">    Used for setting or clearing a flag which determines whether or not an executing macro can be interrupted (using “cmd .”). If n = 0, interruption is not allowed. If n is non-0, it is. This can be used from within a macro to ensure that certain sequences of commands are complete before stopping the macro. (e.g., to be sure that the camera shutter is closed.)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">IMPOWR scale_factor &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Raise the current image to a power specified by a second image in a file. The power is the value in the second image divided by the scale factor.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">INCMACRO n <br /></p>
                <p class="paragraph_style">    Specifies that on each execution of a macro, values should be incremented by value n.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">INTEGRATE direction_flag selection_flag<br /></p>
                <p class="paragraph_style">    Sum up the data in the horizontal ( direction_flag=0 ) or vertical (direction_flag=1 ) direction. The two-dimensional image becomes a single line. If selection_flag=1, the subset of the image specified by the selection rectangle is used. Possible cases are:<br /></p>
                <p class="paragraph_style">    direction_flag = 1 The result is an array in x; sum in y direction<br /></p>
                <p class="paragraph_style">    direction_flag = 0 The result is an array in y; sum in x direction<br /></p>
                <p class="paragraph_style">    selection_box = 1 A selection box specifies what region to sum<br /></p>
                <p class="paragraph_style">    selection_box = 0 Sum all channels or tracks <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">INTFILL direction_flag selection_flag<br /></p>
                <p class="paragraph_style">    As above, but a two-dimensional image is formed by duplicating the  summed values. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">INTVARIABLE variable_name<br /></p>
                <p class="paragraph_style">    Specifies that variable_name is to be used as an integer variable.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">INVERT<br /></p>
                <p class="paragraph_style">    Inverts the image in the current image data buffer, causing the first data point to become the last data point.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">JFCALC<br /></p>
                <p class="paragraph_style">    Using the data in the current buffer as Rayleigh input and the specified file as the fluorescence input, create the conserved scalar image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">JFCONS <br /></p>
                <p class="paragraph_style">    Read in constants to be used for FCALC.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">JFSTRI PE<br /></p>
                <p class="paragraph_style">    Get a stripe response for the image -- j. frank algorithm.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KILBOX [value]<br /></p>
                <p class="paragraph_style">    Much like FILBOX, this command works on the region of the image that has been specified with the RECT command or mouse. The contents of this region are set to 'value'. Default for 'value' is 0.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KINTEGRATE<br /></p>
                <p class="paragraph_style">    The same as the “Plot Integrated” menu item. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KLIMIT flag<br /></p>
                <p class="paragraph_style">    Set the printing flag. If flag = -1, turn off printing but save old status. If flag = -2, restore old status. Other values turn printing on. Cmnd L toggles limited printing.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KPCTR<br /></p>
                <p class="paragraph_style">    The same as the “Plot Contours” menu item. It causes the data in the current buffer to be plotted according to the information in the “Set Contours” menu item.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KRECSV &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Saves a subset of the current data buffer in a specified file. The subset is specified by the current selection rectangle. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KRRGB &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Saves a subset of the current rgb data buffer in a specified file. The subset is specified by the current selection rectangle.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">KWABEL n<br /></p>
                <p class="paragraph_style">    Uses analytic evaluation of integral required for abel inversion, which involves a lot of evaluations of ln(x). n is a scale factor for the image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LABJAK<br /></p>
                <p class="paragraph_style">    Performs a test on a Labjack U12 USB multifunction digital/analog I/O device.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LINCALC<br /></p>
                <p class="paragraph_style">    Calculate line outs specified by the current Line Out Template using the data in the current image buffer. Line Outs calculated previously are discarded.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LINE<br /></p>
                <p class="paragraph_style">    Set all pixels in the specified row of the current image to 1.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LINGET n [multiplier]<br /></p>
                <p class="paragraph_style">    Move the nth Line Out (calculated by LINCAL) into the current data buffer. The previous contents of the data buffer are lost. Since the integrated data may be larger than allowed by the 16 bits of the image buffer, appropriate scale factors are calculated. If the optional multiplier is included, the results are multiplied by that factor before being moved to the data buffer. This could be used to retain small differences that might be lost when normalization is done. (See LINORM command.)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LINORM flag<br /></p>
                <p class="paragraph_style">    If flag = 1, then the results returned by LINGET are normalized to the number of lines integrated over. If flag = 0, no normalization is done.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LINSSB n filename<br /></p>
                <p class="paragraph_style">    Save the nth Line Out subregion in a file with the specified name.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LINSTATS<br /></p>
                <p class="paragraph_style">    Print statistics (ave., rms fluctuation, etc.) for the regions specified in the current Line Out Template.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LIST <br /></p>
                <p class="paragraph_style">    Lists the current detector parameters and log block.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LMACRO <br /></p>
                <p class="paragraph_style">    Lists the contents in the current macro buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LN scale_factor<br /></p>
                <p class="paragraph_style">    Take the natural log of the data in the image buffer. Scale the result by scale_factor.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LOG [n] [comment]<br /></p>
                <p class="paragraph_style">    Adds a comment to the comment buffer at line n. If n is not specified, the comment is added to the beginning of the comment buffer. If “comment” is not present, the program prompts for additional comment lines until a null comment is entered (i.e. &lt;CR&gt; only). If the optional “comment” is included on the same line, the text of “comment” replaces any comment already existing at line n and no further comment lines are solicited.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LOOKUP fn_number <br /></p>
                <p class="paragraph_style">    Redefine the current image using the lookup table specified by a tabulated function. Use GETFUNCT n filename before using this command. Ignore scale factors for now.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LOOP variable_name start end [step]<br /></p>
                <p class="paragraph_style">    Initializes a loop. The variable_name can be any string of reasonable length. The variable takes on the initial value specified by “start” and the commands within the loop are repeated until the variable is &gt;= “end”. ( or &lt;= “end” if step &lt; 0) If step is not specified, a step of 1 is assumed. The end of the loop is specified by the LOOPND command. Each LOOP must have a corresponding LOOPND. To access the value of a loop variable, precede variable_name with “@” For example:<br /></p>
                <p class="paragraph_style">    loop fnum 2 10 2<br /></p>
                <p class="paragraph_style">    get data@fnum<br /></p>
                <p class="paragraph_style">    disp<br /></p>
                <p class="paragraph_style">    loopnd<br /></p>
                <p class="paragraph_style">    .<br /></p>
                <p class="paragraph_style">    .<br /></p>
                <p class="paragraph_style">    Note: To signify the end of a variable name when it is followed by other characters, use a '\' character. For example:<br /></p>
                <p class="paragraph_style">    loop fnum 2 10 2<br /></p>
                <p class="paragraph_style">    get data@fnum\_corrected<br /></p>
                <p class="paragraph_style">    disp<br /></p>
                <p class="paragraph_style">    loopnd<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LOOPBREAK<br /></p>
                <p class="paragraph_style">    Break out of current loop.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LOOPND<br /></p>
                <p class="paragraph_style">    Specifies the end of a loop initiated with the LOOP command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LTLOAD &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Open a Line Out Template file with the specified name.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">LTSAVE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Save the currently defined Line Out Template in the specified file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MACRO [n m]<br /></p>
                <p class="paragraph_style">    Like “RMACRO [n m]” except that printing of intermediate output is automatically suppressed.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MAKNEW n m<br /></p>
                <p class="paragraph_style">    Change the resolution of the data in the current data buffer to be n x m pixels. Linear interpolation is performed. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MAKPIV no_of_points<br /></p>
                <p class="paragraph_style">    Randomly generate a piv particle image. no_of_points is how many point in the image. Max (and default) is 20,000.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MAKPSZ<br /></p>
                <p class="paragraph_style">    Crops an image to an appropriate size for PIV. Uses the values of PIVSIZE and PIVINC to trim away edges that would be ignored by PIV processing<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MASK width height<br /></p>
                <p class="paragraph_style">    Make a “mask” for inverse fft operations. The central region of the current image with the width and height specified will be set to 1. The area around the central region is set to 0. (See FFT command option 8.)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MATCH image2_data_file<br /></p>
                <p class="paragraph_style">    This command is used to create matching image pairs from images taken with different magnification, displacement, and rotation. The first image is assumed to be in the current image buffer. “image2_data_file” specifies the name of a file containing the second image. The necessary image matching parameters are stored in an ASCII text file and must be loaded with the GETMATCH command prior to executing the MATCH command. The command creates two new images and stores them in files named Match_1 and Match_2. Image 1 should be the lower resolution of the two.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MAX <br /></p>
                <p class="paragraph_style">    Prints the minimum and maximum of the data in the current data file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MCALX<br /></p>
                <p class="paragraph_style">    Using the data in the current buffer as Rayleigh input and the specified file as the fuel input, create the conserved scalar image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MCONST<br /></p>
                <p class="paragraph_style">    Read in constants to be used for MCALX.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MIRROR<br /></p>
                <p class="paragraph_style">    Form a left-right mirror image operation on the data in the current data buffer. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MULFILE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Multiplies the contents of the current data buffer by the contents of the specified file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">MULTMP n<br /></p>
                <p class="paragraph_style">    Multiplies the contents of the current data buffer by the contents of temporary image n.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">NAN2ZERO<br /></p>
                <p class="paragraph_style">    This command filters the Image buffer, PIV buffers and Temp image buffers. If a Pixel or Vector contains a 'not-a-number' (nan) then the pixel(s) and/or vector(s) are set to zero.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">NEWWIN flag<br /></p>
                <p class="paragraph_style">    If flag = 1 (default), a new window will be opened for each “DISPLAY” command. There can be a maximum of 9 graphics windows open at one time. If there are already 9 windows open on the screen, subsequent graphics commands will close the oldest window before opening a new one. If flag = 0, the results of “DISPLAY” commands will be placed in the last-opened window. If no window exists, a new one will be opened. If the size of the last-opened window is not appropriate for the current scan parameters, the last-opened window will be closed and a new window opened with the correct size.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">NOISE average rms [seed]<br /></p>
                <p class="paragraph_style">    Creates a noise image with the specified average and rms.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">OF2PIV scale_factor average_flag x_vel_file y_vel_file<br /></p>
                <p class="paragraph_style">    Convert optical flow images into PIV vectors Reads in OMA image formats for x and y velocities Use PIVINC and PIVSIZE to determine how often to plot a vector Scale factor can be float. Average flag (integer) is 0=off 1=on.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">OPENFLAG flag <br /></p>
                <p class="paragraph_style">    flag=1 specifies that files opened with the GET and COMPOSITE commands should not be closed after the first data set is read in, but left open. Subsequently, GET or COMPOSITE commands can be executed with no argument, causing the next in a series of images stored in the single file to be read into the data buffer. flag=0 disables this option and is the default mode.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PAIRLS<br /></p>
                <p class="paragraph_style">    List dx dy and magnitude for pairs.  Points must first be generated <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style"> via the POINTS command and pairs generated via the PAIRS command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PAIRPR<br /></p>
                <p class="paragraph_style">    Process pair statistics for an entire image. Assumes that matching PIV and POINT have already been calculated (e.g., via the PIV and POINTS or PNTMOSAIC commands). Prints out statistics corresponding to pairs for each velocity vector.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PAIRS dx dy radius<br /></p>
                <p class="paragraph_style">    Find pairs of particles separated by dx, dy (to within radius) assumes arrays exist that contain image points and that the points lie within the bounds of the current image. The rectangle is changed to correspond to the entire image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PALETTE n<br /></p>
                <p class="paragraph_style">    Specifies that the nth predefined color palette should be used. Palette 0 is a color palette; 1 is a gray-scale palette.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PARSE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Reads in a TECPLOT vector file from PIVView and converts to an OMA PIV field.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PAUSE [pause_string]<br /></p>
                <p class="paragraph_style">    When executed in a macro, the PAUSE command causes macro execution to be suspended until a key on the keyboard is pressed, at which time the macro will continue execution. If the optional pause_string is included, it will be echoed to the right of the Macro # in the status window. The pause_string can contain variable names or %d type dummy arguments that will be filled in before echoing the string. To terminate a paused macro, type &lt;cmnd period&gt;.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PDFDO flag<br /></p>
                <p class="paragraph_style">    1-D pdf command. Command sequence would be<br /></p>
                <p class="paragraph_style">    pdfsiz 0 1000 100 1  ; 100 bins data values from 0 to 1000<br /></p>
                <p class="paragraph_style">                          ; exclude values outside the range 0 - 1000<br /></p>
                <p class="paragraph_style">    ...load an image.....<br /></p>
                <p class="paragraph_style">    pdfdo 0  ; add all points in the current image to the pdf accumulator<br /></p>
                <p class="paragraph_style">    pdfdo 1  ; get the pdf accumulator<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PDFIT<br /></p>
                <p class="paragraph_style">    Use 2-D fit (hardwired for now) to calculate a scalar from P and D image<br /></p>
                <p class="paragraph_style">    Arguments:<br /></p>
                <p class="paragraph_style">    Depolarized file name<br /></p>
                <p class="paragraph_style">    Rayleigh-cts in air<br /></p>
                <p class="paragraph_style">    Depolarized-cts in air<br /></p>
                <p class="paragraph_style">    Scale factor for new image<br /></p>
                <p class="paragraph_style">    flag: 1 for calculating T, 2 for calculating [CH4], else: xi<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PDFSIZE pdfstart pdfend pdfbins [pdf exclude flag]<br /></p>
                <p class="paragraph_style">    Setup for the 1-D PDFDO command. Default for “pdf exclude flag” is 0.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PEAK #_to_print sum_area exclude_radius<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PEAKIMAGE peakval sum_area exclude_radius<br /></p>
                <p class="paragraph_style">    Replace the image data by a peaks only image. Points greater that peakval are included.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIV- dx dy<br /></p>
                <p class="paragraph_style">    Subtract a constant vector from the currently loaded vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIV sum_area exclude_radius<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIV* scale<br /></p>
                <p class="paragraph_style">    Multiply the currently loaded vectors by a scale factor.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIV/ scale<br /></p>
                <p class="paragraph_style">    Divide the currently loaded vectors by a constant. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIV+ dx dy<br /></p>
                <p class="paragraph_style">    Add a constant vector to the currently loaded vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVABS<br /></p>
                <p class="paragraph_style">    Returns the absolute value of all components in a PIV Field. Note that this only affects the top (visible) layer of vectors and does NOT alter the underlying, alternate peaks. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVADD &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Add vector file to currently loaded vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVALTER flag<br /></p>
                <p class="paragraph_style">    Alter a point calculated by the PIV command. If flag is not 0, turn on alter mode. Interactively shuffle through different peaks. To change a vector, point at the plotted arrow. Rotate a all others up one position.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVANG value<br /></p>
                <p class="paragraph_style">    Strip bad vectors out of a PIV image by checking that it's angle does not differ too much from those around it. The value is a deviation in degrees (15 is the default).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVAVG<br /></p>
                <p class="paragraph_style">    Calculates average vector over entire vector field.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVBAD mag angle replace_flag<br /></p>
                <p class="paragraph_style">    Remove vectors which deviate more than mag in magnitude and angle in angle from those in immediate neighborhood. replace_flag = 1 means put in average of surrounding for bad vectors<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVBIG<br /></p>
                <p class="paragraph_style">    Kind of does what PIVMAX used to do. It returns the 3 components of the maximum visible (top) vector to the Command Window.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVC-<br /></p>
                <p class="paragraph_style">    See PIVC+<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVC* factor<br /></p>
                <p class="paragraph_style">    Conditional PIV arithmetic. Multiplies all NON-ZERO vectors by the scale factor specified in the command line. Only affects the visible (top) vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVC/<br /></p>
                <p class="paragraph_style">    See PIVC*<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVC+ xcomp ycomp<br /></p>
                <p class="paragraph_style">    Conditional PIV arithmetic. Adds the X &amp; Y components specified in the command line to each NON-ZERO vector in a buffer. Only affects the visible (top) vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVCNV<br /></p>
                <p class="paragraph_style">    Convert Pixels/Delay to m/s using parameters from dialog.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVCRS<br /></p>
                <p class="paragraph_style">    Cross correlation PIV command. The second image is stored in the background image (use the “SBACK filename” command).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVDIRECTION<br /></p>
                <p class="paragraph_style">    Alter PIV vectors to orient vectors in preferred direction (as set by PIVSET command).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVDIVIDE<br /></p>
                <p class="paragraph_style">    Divide the currently loaded vectors by the scalar image in the current buffer. This could be used to do conditional averages -- the number of points in the scalar field would be the same as the number of vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVDOT<br /></p>
                <p class="paragraph_style">    Dot product of PIV buffer with PIV in file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVEXE<br /></p>
                <p class="paragraph_style">    Execute throughput PIV processing algorithm. (see EXECUTE command).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVFILL<br /></p>
                <p class="paragraph_style">    Interpolate zero vectors in field from neighbors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVFLH<br /></p>
                <p class="paragraph_style">    Flip the PIV Field in the OMA PIV buffer horizontally. This transformation is applied to all the peaks in the image, including the visible vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVFLV<br /></p>
                <p class="paragraph_style">    Flip the PIV Field in the OMA PIV buffer vertically. This transformation is applied to all the peaks in the image, including the visible vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVFTR<br /></p>
                <p class="paragraph_style">    Filter PIV based on local neighborhood mean.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVGET &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Load PIV data from file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVINC<br /></p>
                <p class="paragraph_style">    Specify the increment (in pixels) between successive samples in the PIV command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVLST<br /></p>
                <p class="paragraph_style">    List the current PIV data.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVM*<br /></p>
                <p class="paragraph_style">    Each vector in the PIV buffer is multiplied by a scalar variable equal to the value of the corresponding pixel in the OMA Image buffer. Only affects the visible (top) vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVM/<br /></p>
                <p class="paragraph_style">    Each vector in the PIV buffer is divided by a scalar variable equal to the value of the corresponding pixel in the OMA Image buffer. Only affects the visible (top) vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVMAG accuracy<br /></p>
                <p class="paragraph_style">    Kill any vector in image whose magnitude differs from the neighborhood average.  accuracy is the threshold of accuracy for vector comparison; 0=different; 1.0= identical; default is accuracy = 0.65.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVMAX<br /></p>
                <p class="paragraph_style">    Specifies the maximum allowed length of vectors in a PIV Field. Vectors longer than this limit are set to zero. Only affects the visible (top) vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVMIN<br /></p>
                <p class="paragraph_style">    Specifies the minimum allowed length of vectors in a PIV Field. Vectors shorter than this limit are set to zero. Only affects the visible (top)  vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVMSG<br /></p>
                <p class="paragraph_style">    Massage PIV data. Auto correct a PIV image This is done using an iterative application similar to that using PIVALT  mode 3.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVMULT<br /></p>
                <p class="paragraph_style">    Multiply the currently loaded vectors by the scalar image in the current buffer. This could be used to apply a mask (scalar image with 1's and 0's) to the vector field.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVPLT scale <br /></p>
                <p class="paragraph_style">    Plot the current PIV data. Scale vectors by scale (float).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVREFORMAT cp np<br /></p>
                <p class="paragraph_style">    Reformat piv data to have cp as center pixel, np peaks<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVRMV [deviation_magnitude deviation_angle set_avg_flag] <br /></p>
                <p class="paragraph_style">    Try to remove bad vectors -- those with deviation &gt; given. Set bad vectors = 0.0 or replace by local avg if requested.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVRND dx dy pix_value num_pairs<br /></p>
                <p class="paragraph_style">    Generate a simulated double-exposure PIV image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVROT<br /></p>
                <p class="paragraph_style">    Rotate the PIV Field by 90 degrees clockwise. The Vectors are also rotated 90 degrees, swapping X &amp; Y components. Four PIVROT will leave the original image unchanged.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSAVE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Save current PIV data to file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSET<br /></p>
                <p class="paragraph_style">    Set values of constants used in the PIV command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSHT [exrad]<br /></p>
                <p class="paragraph_style">    Remove vectors shorter than exrad.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSIZE<br /></p>
                <p class="paragraph_style">    Specify the size of fft done in the piv command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSQRT<br /></p>
                <p class="paragraph_style">    Get square root of each component of the currently loaded vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSUB &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Subtract vector file to currently loaded vectors.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVSUC &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Subtract vector file: only do subtraction from vectors in currently loaded vector field.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVUODETECT<br /></p>
                <p class="paragraph_style">     PIV command that implements the Universal Outlier detection algorithm of J. Westerweel and F. Scarano “Universal Outlier Detection for PIV data” Experiments in Fluids [39]:1096-1100 (2005).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVX<br /></p>
                <p class="paragraph_style">    Extract the x-component.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVX2Y<br /></p>
                <p class="paragraph_style">    Writes the X-component of the visible vectors into the Y-component so that both are identical. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVY<br /></p>
                <p class="paragraph_style">    Extract the y-component.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIVY2X<br /></p>
                <p class="paragraph_style">    Writes the Y-component of the visible vectors into the X-component so that both are identical.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIXSIZE n<br /></p>
                <p class="paragraph_style">    Specifies the number of pixels on the Macintosh screen that will be used to represent each data word in the current image buffer. PIXSIZE 1 associates one Macintosh screen pixel with one data point. For n positive, PIXSIZE specifies that n pixels are to be used for each data point. If n is negative, a reduced picture is displayed with only every nth data point from the image data being displayed as one Macintosh pixel. (Good for large pictures and small screens.)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PIXVALUE x y<br /></p>
                <p class="paragraph_style">    Prints the value of the pixel at location x,y (i.e, at column x and row y). The upper left of an image is at 0,0.<br /></p>
                <p class="paragraph_style">    command_return_1 is the value.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PMACRO n <br /></p>
                <p class="paragraph_style">    Executes commands in the current macro buffer with “%d”s being replaced by the value n.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PNTIMG <br /></p>
                <p class="paragraph_style">    Replace the image data by a points only image. Points must first be generated via the POINTS command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PNTMOSAIC scale<br /></p>
                <p class="paragraph_style">    Find the points (particle images usually) in a large image. The large image is treated as a mosaic of smaller images (size specified by PIVSIZE). As in POINTS, the centroids of connected areas are found, along with integrated intensities and areas. This information is stored in memory. The clipvalue is determined as fraction of the range in each subimage. For example, a scale of 0.5 would use 50% of the largest peak height within the subimage as the clip value. Use the PIVSET command to enable the histogram clipping feature to exclude erroneous minimum and values.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">POINTS clipval<br /></p>
                <p class="paragraph_style">    For those points greater than clipval, the centroids of connected areas are found, along with integrated intensities and areas. This information is stored in memory.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">POLARN<br /></p>
                <p class="paragraph_style">    Custom function by pkalt used for polaristion processing.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">POPULN &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Creates a CSV (Comma Separated Value) file named 'filename' of the histogram of values appearing within in an image. Creates 1024 bins, many of which will be zero if the image has less than 1024 discrete values.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">POSITVE<br /></p>
                <p class="paragraph_style">    Sets all negative values in the image buffer to 0.  Positive values are unaffected.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">POWER y<br /></p>
                <p class="paragraph_style">    Raise the data in the current image buffer to the power y (float). <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PREFIX [fileprefix] <br /></p>
                <p class="paragraph_style">    Specifies a “prefix” to be added to all filenames accessed through keyboard commands. This can be used to specify a default “/disk/ folder/subfolder/”. If no prefix is specified, the folder containing the oma program is the used as the default directory.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PRFLAG flag<br /></p>
                <p class="paragraph_style">    If “flag” is set to 0, no printing will be echoed to the command window. <br /></p>
                <p class="paragraph_style">    If “flag” is non-zero, printing is controlled as normal.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PRIMG type<br /></p>
                <p class="paragraph_style">    Replace the image data by a point-pair image. Points must first be generated via the POINTS command and pairs generated via the PAIRS command. Type = 0 assigns inten/area. Type = 1 assigns total inten. Type = 2 assigns ratio of intensities.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">PRINFO<br /></p>
                <p class="paragraph_style">    Provide info on point pairs. Points must first be generated via the POINTS command and pairs generated via the PAIRS command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RAMP<br /></p>
                <p class="paragraph_style">    Fill current image with a ramp from 0 to the number of number of channels.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RECTANGLE ulx uly lrx lry<br /></p>
                <p class="paragraph_style">    Specify a rectangle that calculations are to be done on. The arguments are upper left x coordinate; upper left y coordinate; lower right x; lower right y.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RECTCENTER n m<br /></p>
                <p class="paragraph_style">    Select rectangle of size n x m about center of image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">-RGB x y z<br /></p>
                <p class="paragraph_style">    Subtract x from the red, y from the green, and z from the blue part of the current (assumed RGB) image in the buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RMACRO [n m] <br /></p>
                <p class="paragraph_style">    Starts executing commands in the macro buffer with %d being replaced first by value n. Subsequently, n is incremented by the amount specified in the INCMACRO command (default is 1). If the new numeric value is equal to m, the macro will be executed again. Menu items can be selected and the appropriate commands executed during macros. Commands typed during the execution of a macro will be echoed to the terminal but not performed. To stop a macro during execution type “cmd .” (hold down the apple key and type “.”)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RNDOFF<br /></p>
                <p class="paragraph_style">    Round the DATAWORD values Down to the nearest integer value.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RNDUP<br /></p>
                <p class="paragraph_style">    Round the DATAWORD values UP to the nearest integer value.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ROTATE [value]<br /></p>
                <p class="paragraph_style">    Rotates the data in the current image buffer.  If no value is specified, the image is value is specified, the image is rotated by the specified number of degrees (this may be a real number).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ROTCRP rotation_angle<br /></p>
                <p class="paragraph_style">    This command does the following operations using other internal routines<br /></p>
                <p class="paragraph_style">    1) rotate the existing image by “rotation_angle”.<br /></p>
                <p class="paragraph_style">    2) crop the rotated image to be so that no “filled” pixels are present (will be smaller than original).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">ROW n<br /></p>
                <p class="paragraph_style">    Specifies that n tracks (or rows) should be read from the detector.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RULER [numpix] [numunits] [unit name] <br /></p>
                <p class="paragraph_style">    Can be used to specify the number of pixels that correspond to a length unit. “numpix” and “numunits” are both floating point arguments. An optional string can be included to define the units (e.g., “mm” or “feet”). If no arguments are given, the current scale factor will be printed. The scale factor defined with the RULER command is used (1) when printing lengths using the ruler tool in the status window, (2) when reporting contour lengths generated by the “Plot Contours” menu command, and (3) when reporting the x and y “center of mass” using the calculate rectangle tool in the status window. Scale factor info is saved with data files and will be reloaded automatically when the files are retrieved. To “un-define” a ruler, give only one argument.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">RYCALC &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Using the data in the current buffer as rayleigh input and the specified file as the fluorescence input, create the conserved scalar image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SATIFF &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Converts the contents of the OMA Image buffer to 8 bit unsigned data and then uses the LibTIFF TIFFWriteEncodedStrip function to save the data to a TIFF image specified on the command line. The 'save' file prefixes are used. A “.tif” extension is automatically appended to the filename.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SATIFFSCALED min max &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Convert image to 8 bit and save as a Greyscale TIFF file. Uses the specified min and max for scaling rather than the min and max of the image in the buffer. Results will be between 0 - 255. Depending on min and max, the image may be clipped or the full 8-bit dynamic range may not be used.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SAUTER &lt;filename&gt; &lt;Factor&gt;<br /></p>
                <p class="paragraph_style">    Do a division of LIF and MIE images using floating point arithmetic. <br /></p>
                <p class="paragraph_style">    &lt;filename&gt;   name of file to act as the denominator<br /></p>
                <p class="paragraph_style">    &lt;Factor&gt;   scales the resulting image by this amount<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SAVE &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Saves the current data buffer to the specified file.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SAVPDF &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Saves the contents of the active window to a pdf file. This works for false color as well as linegraphics windows. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SAVSETTINGS [filename]<br /></p>
                <p class="paragraph_style">    Saves the current settings to the specified file (uses the appropriate prefix and suffix specified in the preferences). If no filename is given, OMA Settings are saved within the oma application. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SBACK<br /></p>
                <p class="paragraph_style">    Save the data in the current data buffer as a background to be used by the CORECT command. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SCALC center start end findpeak<br /></p>
                <p class="paragraph_style">    Spectra Calc - locates peak and centers on it of findpeak != 0. SCALC requires estimate of peak location, the + and - limits and whether to locate the peak (1, default) or not (0) : e.g., SCALC 179 -5 +5 1<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SCALC1 center start end refpeak <br /></p>
                <p class="paragraph_style">    SCALC requires estimate of peak location, the + and - limits and a reference peak e.g., SCALC1 203 -5 +5 203<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SCATTER xsize ysize xmin xmax ymin ymax <br /></p>
                <p class="paragraph_style">    Displays a scatter plot from first and second half of current image. Size of scatter plot is specified by xsize and ysize. Bin size is determined by the min and max values of each half.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SERCLOSE<br /></p>
                <p class="paragraph_style">    Closes the serial port opened with the last “SERIAL device_name” command. This can be used if you need to talk to more than one serial device -- open device 1, send commands, close the serial port, open device 2, send commands, and so forth.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SERIAL device_name (or character_string)<br /></p>
                <p class="paragraph_style">    Provides a simple way of sending text strings to a serial device. For example, a KeySpan USB to serial converter can be used to control a variety stepping motor controllers, spectrographs, etc. The device name should be something like “/dev/tty.KeySpan1” Note that upper/lower case matters on these specifications. Look in the “/dev” directory to find the name of your specific hardware. After opening the device with the first SERIAL command, subsequent SERIAL commands will send across the specified character_string, followed by a &lt;CR&gt;. This uses standard POSIX calls.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SFORMT n<br /></p>
                <p class="paragraph_style">    Save the current camera format as format n. n is in the range 0-7.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SHIFT <br /></p>
                <p class="paragraph_style">    Shifts the current image by an amount determined by the current PIV field. Useful for sub-pixel matching between images. (Uses 8-parameter bilinear method). Does this between each node of the PIV field. &lt;Screws up the edges if the PIV field is significantly smaller than the image in the buffer.&gt; Works nicely if the PIV field and image are the same size with no unused edges at the edge.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SINGRD <br /></p>
                <p class="paragraph_style">    Draw grid from the sine function.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SINKPK [radius no_of_flags]<br /></p>
                <p class="paragraph_style">    Is the pixel likely to be a local minima?<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SIT <br /></p>
                <p class="paragraph_style">    Specifies that the data format is that appropriate for the SIT vidicon detector. Image data is stored to files in 1s complement format. There is no 80 word header at the beginning of the data area. This option is included for compatibility with previous SIT data sets.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SMACRO <br /></p>
                <p class="paragraph_style">    Saves the contents of the current macro buffer to a specified file. SMACRO is also used to save commands to be used with the EXECUTE command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SMEAN<br /></p>
                <p class="paragraph_style">    Save the data in the current data buffer as a mean to be used by the FLUCTUATION command. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SMEAR amount<br /></p>
                <p class="paragraph_style">    Process pixels &gt; 0 by the specified amount (float). Negative values are set to 0.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SMOOTH [n,m] <br /></p>
                <p class="paragraph_style">    Performs an n x m smoothing operation on data in the current image buffer.  If only n is specified, an n x n smoothing is done; with no argument, a 2 x 2 smoothing is performed.  For the smoothing operation to be perfectly centered on each data point, the arguments must be odd. For Gaussian smoothing, use GSMOOTH.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SOLGB &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Get a Yale laminar flame calculation.<br /></p>
                <p class="paragraph_style">    Read in binary numbers for a single variable. Assumes solget has been read in first. Use SOLMAKE to get the image.<br /></p>
                <p class="paragraph_style">     <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SOLGET &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Get a Yale binary laminar flame calculation.<br /></p>
                <p class="paragraph_style">    <br /></p>
                <p class="paragraph_style">     <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SOLGF<br /></p>
                <p class="paragraph_style">    Read in a string of formatted numbers for a single variable. Assumes solget has been read in first. Use solmak to get the image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SOLMAKE x0 y0 x1 y1<br /></p>
                <p class="paragraph_style">    Make an image from the solution read in SOLGET.  x0 y0 x1 y1 are floating point numbers that specify the sub rectangle of the solution. current ruler determines the resolution. command-return: species multiplier (float)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SOLMULT snum mult moleflag<br /></p>
                <p class="paragraph_style">    Specify the species_number, multiplier, and mole_fraction_flag to be used in SOLMAKE <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SPEX command_string [parameters]<br /></p>
                <p class="paragraph_style">    command_string specifies a SPEX command.<br /></p>
                <p class="paragraph_style">    The values for parameters depend on the particular command.<br /></p>
                <p class="paragraph_style">    Commands are as follows:<br /></p>
                <p class="paragraph_style">    INIT  initialize the spectrometer<br /></p>
                <p class="paragraph_style">    GRATING  set the grating (in nm)<br /></p>
                <p class="paragraph_style">    SLIT  set the slit width (in microns)<br /></p>
                <p class="paragraph_style">    VERSION  echo software version<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SQRT<br /></p>
                <p class="paragraph_style">    Take the square root of the data in the current image buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SQUARE<br /></p>
                <p class="paragraph_style">    Square the data in the current image data buffer. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SRESPONSE<br /></p>
                <p class="paragraph_style">    Save the data in the current data buffer as a response to be used by the CORECT command. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">STEMP n<br /></p>
                <p class="paragraph_style">    Save current image as temporary image n. This can be retrieved with GTEMP.<br /></p>
                <p class="paragraph_style">    n must be in the range 0-9.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">STREAM x0 y0 scale_factor<br /></p>
                <p class="paragraph_style">    x0 y0 is the starting location of the ray that will be propagated mainly in the x direction. The two components of the velocity field are needed. The y velocity is stored with SBACK; the x velocity field is in the current image buffer. On return, the image is zero except for the stream line. Values along the stream line correspond to elapsed time as determined by the scale_factor. time = distance/velocity*scale_factor. Distance is in pixels; velocity as per values in velocity files.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">STRIPE start_col end_col rotation_angle [ave_value] <br /></p>
                <p class="paragraph_style">    This command does the following operations using other internal routines<br /></p>
                <p class="paragraph_style">    1) rotate the existing image by “rotation_angle”.<br /></p>
                <p class="paragraph_style">    2) crop the rotated image to be so that no “filled” pixels are present (will be smaller than original). <br /></p>
                <p class="paragraph_style">    3) divide each row of the image by the average of the pixels between start_col and end_col. If ave_value is not specified, the average of the region inside the box will be used.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">STRMACRO string<br /></p>
                <p class="paragraph_style">    Specifies that “string” is to be substituted for any “%s” found in macro or execute commands. If no string is specified, the current string is printed.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">STRTIM x0 dy scale_factor<br /></p>
                <p class="paragraph_style">    This plots a series of streamlines in the image (similar to a loop containing STREAM commands). x0 is the starting location of the ray that will be propagated mainly in the x direction. dy is increment between rays and can be less than one pixel if a continuous “time elapsed” image is desired. When more than one elapsed time occurs within a given pixel, the minimum value is given. The two components of the velocity field are needed. The y velocity is stored with SBACK; the x velocity field is in the current image buffer. On return, the image is zero except for the stream lines. Values along the stream line correspond to elapsed time as determined by the scale_factor. time = distance/velocity*scale_factor. Distance is in pixels; velocity as per values in velocity files.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SUBFILE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Subtracts the contents of the specified file from the data in the current buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SUBSAMPLE n [m]<br /></p>
                <p class="paragraph_style">    Sub-sample the current image, keeping every n-th and m-th pixel and discarding the rest. This command does not do any interpolation (as MAKNEW does) or pixel summing (as BLOCK does). If m is omitted, it is taken equal to n. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SUBTMP n<br /></p>
                <p class="paragraph_style">    Subtracts the contents of temporary image n from the data in the current buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SUFFIX [filesuffix] <br /></p>
                <p class="paragraph_style">    Specifies a “suffix” or extension to be added to all filenames accessed through keyboard commands. If no suffix is specified, a null suffix is used.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SWAPBYTES flag <br /></p>
                <p class="paragraph_style">    The SWAPBYTES command sets or clears a flag that determines if the GET and SAVE commands swap byte order on data read in or saved. This is included for cross-platform compatibility between Mac and Intel worlds. The flag should normally be set to 0 unless you are migrating data from one platform to another. This only affects GET and SAVE -- all other commands that use files leave the byte order alone.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">SWAPIX old new<br /></p>
                <p class="paragraph_style">    This command goes through an image and swaps all occurrences of pixels with the value ='old', to now hold the value ='new'.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TECPLT &lt;filename&gt; <br /></p>
                <p class="paragraph_style">    Exports the currently loaded PIV image to a text file called 'filename', in a format readable by the TecPlot graphics program.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TRACE y0 angle factor<br /></p>
                <p class="paragraph_style">    Ray trace across the image continuous. Image interpreted as local index of refraction. y0 is the starting location of the ray. If y0 is positive, a single ray is drawn. If y0 is negative, it is taken as an increment, and many rays are traced across the image. e.g., y= -5 would trace a ray every 5th pixel. y0 = -0.1 would trace 10 rays across  each pixel over the entire image. Angle is the initial propagation direction (in radians, 0 is horizontal). Factor is the amount that the data are divided by in calculating the index (index = 1.0 + signal/scale_factor).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TRACE2 y0 angle index2<br /></p>
                <p class="paragraph_style">    Ray trace across contour lines.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TRACKS n<br /></p>
                <p class="paragraph_style">    Specifies that n tracks (or rows) should be read from the detector.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TRACOR y0 angle factor smooth<br /></p>
                <p class="paragraph_style">    Column-wise ray trace across the image. Image interpreted as local index of refraction. y0 is an increment between consecutive rays. <br /></p>
                <p class="paragraph_style">    y0 = 5 would trace a ray every 5th pixel.<br /></p>
                <p class="paragraph_style">    y0 = 0.1 would trace 10 rays across  each pixel over the entire image.<br /></p>
                <p class="paragraph_style">    Angle is the initial propagation direction (in radians, 0 is horizontal). Factor is the amount that the data are divided by in calculating the index (index = 1.0 + signal/scale_factor). smooth is the amount a column is Gaussian smoothed before being projected forward.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TRACPT 1/f# dtheta scale_factor<br /></p>
                <p class="paragraph_style">    Ray trace from a point in the center-left of the image, through an ideal lens near the center of the image. The continuous image is interpreted as local index of refraction (index = 1.0 + signal/scale_factor). The inverse f# determines the angle over which rays from the point will be traced. dtheta (in radians) determines the increment between rays (smaller = more rays). Factor is the amount that the data are divided by in calculating the index.<br /></p>
                <p class="paragraph_style">    (index = 1.0 + signal/scale_factor).<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TRPDF pix_inc angle scale_factor pix_offset num_bins bin_width<br /></p>
                <p class="paragraph_style">    Ray trace across an image and return the pdf of pixel displacements. The continuous image is interpreted as local index of refraction (index = 1.0 + signal/scale_factor). pix_inc an increment between successive traces (floating pt); pix_offset is how far away to stay from the top and bottom of the image; angle is the initial propagation direction (in radians, 0 is horizontal); num_bins is the number of bins in the returned histogram; bin_width is the bin width.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">TSMOOTH<br /></p>
                <p class="paragraph_style">    Smooth radius based on x_dim = Temp[0], y_dim = Temp[1]<br /></p>
                <p class="paragraph_style">    This is a function that enables (Rectangular) smoothing of an image, with variable filter size. It works basically like SMOOTH 13 13, say, but it takes the x_dim and y_dim locally based on the values in the  Temporary buffers T[0] and T[1]. It has been used to variably smooth an image based on the local length scale which was modelled. <br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">UFORMT n<br /></p>
                <p class="paragraph_style">    Restore camera format n previously saved using the SFORMT command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">UPREFX type <br /></p>
                <p class="paragraph_style">    Force use of prefix/suffix specified by 'type.' Possible cases for 'type' include the following: <br /></p>
                <p class="paragraph_style">    s   Use Save File prefix and suffix <br /></p>
                <p class="paragraph_style">    g   Use Get File prefix and suffix <br /></p>
                <p class="paragraph_style">    d   Use Default prefix and suffix<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VALMACRO [Startval Incval]<br /></p>
                <p class="paragraph_style">    Resets the %v value to “Startval” (0 is default) with an increment of “Incval”<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VARIABLES<br /></p>
                <p class="paragraph_style">    Lists currently defined variables and their values. Variables are defined using simple arithmetic expressions, such as<br /></p>
                <p class="paragraph_style">    my_var = 10<br /></p>
                <p class="paragraph_style">    or<br /></p>
                <p class="paragraph_style">    y = my_var*2<br /></p>
                <p class="paragraph_style">    The values of variables are accessed from other commands using @my_var. For example,<br /></p>
                <p class="paragraph_style">    + @my_var<br /></p>
                <p class="paragraph_style">    or<br /></p>
                <p class="paragraph_style">    save datfile_@4myvar<br /></p>
                <p class="paragraph_style">    As with loops, the end of a variable can be tagged by adding a '\' For example,<br /></p>
                <p class="paragraph_style">    save datfile_@my_var\_corrected<br /></p>
                <p class="paragraph_style">    See also commands FLOAT and INTVARIABLE<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VECIMG n<br /></p>
                <p class="paragraph_style">    Record the vector magnitudes (scaled by n) in the image buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VECIMX n<br /></p>
                <p class="paragraph_style">    Record the x-component of velocity (scaled by n) in the image buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VECIMY n<br /></p>
                <p class="paragraph_style">    Record the y-component of velocity (scaled by n) in the image buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VORT2 scale<br /></p>
                <p class="paragraph_style">    calculate the vorticity another way -- simply differences<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">VORTICITY scale<br /></p>
                <p class="paragraph_style">    Calculate vorticity; calculation method from Reuss et al. -- circulation around a closed contour surrounding the point<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">WAITHI bit_number<br /></p>
                <p class="paragraph_style">    Waits until the specified digital I/O bit is asserted high on a LabJack U12. Don't use bit_number = 2, as that is reserved for output using the DOUT command.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">WARP subpix<br /></p>
                <p class="paragraph_style">    Remaps an image coordinate system using bilinear geometric warping.<br /></p>
                <p class="paragraph_style">    x’ = a00 + a01x + a10y + a11xy<br /></p>
                <p class="paragraph_style">    y’ = b00 + b01x + b10y + b11xy<br /></p>
                <p class="paragraph_style">    The 8 parameters must first be read in with the WARPARAMS command. the subpix command specifies subpixel resolution used (default is 0.2). Without subpixel sampling, there would likely be holes in the warped image.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">WARPARAMS &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Reads in 8 warp parameters from the specified file. The format of the text file should be as follows:<br /></p>
                <p class="paragraph_style">    a00 a01 a10 a11<br /></p>
                <p class="paragraph_style">    b00 b01 b10 b11<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">WDATA n <br /></p>
                <p class="paragraph_style">    Writes n data words from the current image data buffer.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">X0 n<br /></p>
                <p class="paragraph_style">    Specifies that the detector is to be read out starting at channel n.<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">XCORRELATE &lt;filename&gt;<br /></p>
                <p class="paragraph_style">    Another cross correlation PIV command. The second image is in the specified file. (P. Kalt algorithm)<br /></p>
                <p class="paragraph_style"><br /></p>
                <p class="paragraph_style">Y0 n<br /></p>
                <p class="paragraph_style">    Specifies that the detector is to be read out starting at track n.<br /></p>
                <p class="paragraph_style"><span style="line-height: 15px; " class="style_1"><br /></span></p>
              </div>
              <div style="height: 14px; line-height: 14px; " class="tinyText"> </div>
            </div>
          </div>
          


          <div id="id1" style="height: 49px; left: 35px; position: absolute; top: 22px; width: 630px; z-index: 1; " class="style_SkipStroke_1">
            <div class="text-content graphic_shape_layout_style_default_External_630_49" style="padding: 0px; ">
              <div class="graphic_shape_layout_style_default">
                <p style="padding-bottom: 0pt; padding-top: 0pt; " class="Title">All Commands</p>
              </div>
            </div>
          </div>
          


          <div style="height: 1px; width: 630px;  height: 0px; left: 35px; position: absolute; top: 1px; width: 630px; z-index: 1; " class="tinyText">
            <div style="position: relative; width: 630px; ">
              <img src="Index_files/shapeimage_1.jpg" alt="" style="height: 1px; left: 0px; position: absolute; top: 0px; width: 630px; " />
            </div>
          </div>
          <div style="height: 0px; line-height: 0px; " class="spacer"> </div>
        </div>
        <div style="height: 150px; margin-left: 0px; position: relative; width: 720px; z-index: 15; " id="footer_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
        </div>
      </div>
    </div>
  </body>
</html>


