/********************************************************************                Copyright (C) 1994, Photometrics, Ltd.********************************************************************/#include "impdefs.h"#define __mac_os_x	// tell the pvcam software what's up#include "master.h"#include "pvcam.h"#include "cam_func.h"/***************************************************************** * init_spdtab * * This function initializes the speed table entry "spd_num" in * the data structure whose address is passed in with the speed * table information for that speed. It assumes that the following * fields are valid: *  data->hcam * It uses the hcam field to fill in the remainder of the data * structure from the open camera. * * Inputs: a pointer to a camera_data_type structure, the speed. * Outputs: the speed table entry in the structure is initialized. * Returns: PV_FAIL if something doesn't work, or PV_OK * ****************************************************************/static boolean init_spdtab(camera_data_ptr data,int16 spd_num){    int16 x;    if(!pl_spdtab_get_bits(data->hcam,&x) ) {        return(PV_FAIL);    }    data->spd[spd_num].bit_depth = (uns8) x;    if(!pl_spdtab_get_time(data->hcam,&data->spd[spd_num].ns_per_pixel)){        return(PV_FAIL);    }    data->spd[spd_num].gain[0] = GAIN_NOT_AVAILABLE;    for( x=1 ; x<MAX_GAINS ; x++ ) {        if( pl_spdtab_set_gain(data->hcam,x) == PV_OK ) {            data->spd[spd_num].gain[x] = GAIN_AVAILABLE;        }        else {            data->spd[spd_num].gain[x] = GAIN_NOT_AVAILABLE;        }    }    return(pl_spdtab_get_port(data->hcam,&data->spd[spd_num].port));}/***************************************************************** * init_camera_data * * This function initializes the data structure whose address is * passed in with data about the PVCAM environment. It assumes * that the following fields are valid: *  data->total_cameras *  data->hcam *  data->camera *  data->menu_cam * It uses the hcam field to fill in the remainder of the data * structure from the open camera. * * Inputs: a pointer to a camera_data_type structure. * Outputs: the structure is initialized. * Returns: PV_FAIL if something doesn't work, or PV_OK * ****************************************************************/static boolean init_camera_data(camera_data_ptr data){    int16 x;    if( !pl_spdtab_get_entries(data->hcam,&x) ) {        return(PV_FAIL);    }    if( x > MAX_SPEEDS ) {        x = MAX_SPEEDS;    }    data->speed_table_entries = (uns8) x;    if( !pl_spdtab_get_gain(data->hcam,&x) ) {        return(PV_FAIL);    }    data->gain_now = (uns8) x;    if( !pl_spdtab_get_num(data->hcam,&x) ) {        return(PV_FAIL);    }    data->max_recommended_speed = (uns8) x;    if( !init_spdtab(data,x) ) {        return(PV_FAIL);    }    for( x=0 ; (int) x<(int) data->speed_table_entries ; x++ ) {        if( x != (int16) data->max_recommended_speed ) {            if( !pl_spdtab_set_num(data->hcam,x) ) {                return(PV_FAIL);            }            if( !init_spdtab(data,x) ) {                return(PV_FAIL);            }        }    }    if( !pl_spdtab_set_num(data->hcam,data->max_recommended_speed) ) {        return(PV_FAIL);    }    data->speed_now = data->max_recommended_speed;    if( !pl_spdtab_set_gain(data->hcam,(int16) data->gain_now) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_ser_size(data->hcam,&data->s_max) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_par_size(data->hcam,&data->p_max) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_chip_name(data->hcam,data->ccd_name) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_frame_capable(data->hcam,&data->frame_capable) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_fwell_capacity(data->hcam,&data->fwell_capacity) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_cooling_mode(data->hcam,&data->cooling) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_mpp_capable(data->hcam,&data->mpp_capable) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_premask(data->hcam,&data->pre_mask) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_prescan(data->hcam,&data->prescan) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_postmask(data->hcam,&data->post_mask) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_postscan(data->hcam,&data->postscan) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_serial_num(data->hcam,&data->serial_num) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_summing_well(data->hcam,&data->s_well_exists) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_pix_par_dist(data->hcam,&data->pix_par_dist) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_pix_par_size(data->hcam,&data->pix_par_size) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_pix_ser_dist(data->hcam,&data->pix_ser_dist) ) {        return(PV_FAIL);    }    if( !pl_ccd_get_pix_ser_size(data->hcam,&data->pix_ser_size) ) {        return(PV_FAIL);    }    if( !pl_dd_get_ver(data->hcam,&data->dd_ver) ) {        return(PV_FAIL);    }    data->region.s_offset = data->region.p_offset = 0;    data->region.s_bin = data->region.p_bin = 1;    data->region.s_size = data->s_max;    data->region.p_size = data->p_max;    return(PV_OK);}/***************************************************************** * init_data_structures * * This function initializes the data structure who's address is * passed in with data about the PVCAM environment. It fills in * the names of all available cameras and tries to open one of * them. The remainder of the data structure is filled in from * the one that is opened. * * Inputs: a pointer to a camera_data_type structure. * Outputs: the structure is initialized. * Returns: PV_FAIL if something doesn't work, or PV_OK * ****************************************************************/boolean init_data_structures(camera_data_ptr data){    int16 i,x;    /* Get total number of cameras. */    if(!pl_cam_get_total(&data->total_cameras) ||        (data->total_cameras < 1)) {        return(PV_FAIL);    }    /* Get name of each camera. */    for(i=0; i<data->total_cameras; i++) {        if(!pl_cam_get_name(i,data->camera[i])) {            return(PV_FAIL);        }    }    for(i=0; i<data->total_cameras; i++) {        if(pl_cam_open(data->camera[i],&x,OPEN_EXCLUSIVE)) {            data->menu_cam = i;            data->hcam = x;            break;        }    }    if( i == data->total_cameras ) {        return(PV_FAIL);    }    if( !pl_pvcam_get_ver(&data->pvcam_ver) ) {        return(PV_FAIL);    }	/*    if( !pl_ddi_get_ver(&data->ddi_ver) ) {        return(PV_FAIL);    }	*/    data->exposure_time = 100L;    data->exposure_units = MILLISECONDS_DISPLAY;    data->exposure_mode = TIMED_MODE;    data->data_max = data->data_min = data->display_min = 0;    data->display_max = (uns16) ((1 << data->spd[data->speed_now].bit_depth) - 1);    data->auto_contrast = TRUE;    data->exposure_cycles = 100;    return(init_camera_data(data));}/***************************************************************** * open_new_camera * * This function opens the new camera indicated by the new_cam * entry in the data->camera field of the data structure passed * in. It then closes the previously open camera and initializes * the remainder of the data structure with data from the newly * opened camera. * * Inputs: a pointer to a camera_data_type structure, a camera id. * Outputs: the structure is initialized. * Returns: PV_FAIL if something doesn't work, or PV_OK * ****************************************************************/boolean open_new_camera(camera_data_ptr data,uns16 new_cam){    int16 x;    if( (int) new_cam >= (int) data->total_cameras ) {        return(PV_FAIL);    }    if( !pl_cam_open(data->camera[new_cam],&x,OPEN_EXCLUSIVE) ) {        return(PV_FAIL);    }    if( !pl_cam_close(data->hcam) ) {        /* Disaster! The old one won't close. */        //warning_dialog(pl_error_code(),"attempting to close the old camera.");    }    data->hcam = x;    data->menu_cam = new_cam;    return(init_camera_data(data));}/***************************************************************** * setup_one_exposure * * This function uses the data in the camera_data_type structure * to prepare PVCAM to perform the indicated exposure. * * Inputs: a pointer to a camera_data_type structure. * Outputs: camera's CCS is initialized and ready. * Returns: PV_FAIL if something doesn't work, or PV_OK * ****************************************************************/boolean setup_one_exposure(camera_data_ptr data,uns32_ptr stream_size){    rgn_type region;    region.s1   = data->region.s_offset;    region.s2   = (uns16) (data->region.s_offset + data->region.s_size - 1);    region.sbin = data->region.s_bin;    region.p1   = data->region.p_offset;    region.p2   = (uns16) (data->region.p_offset + data->region.p_size - 1);    region.pbin = data->region.p_bin;    return(pl_exp_setup_seq(data->hcam,1,1,&region,data->exposure_mode,                            data->exposure_time,stream_size));}